datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

enum ProblemStatus {
  REPORTED
  IN_REVIEW
  IN_PROGRESS
  RESOLVED
  REJECTED
}

model Problem {
  id              Int             @id @default(autoincrement())
  reporterPhone   String          @map("reporter_phone")
  rawMessage      String          @map("raw_message")
  title           String
  locationText    String?         @map("location_text")
  latitude        Float?
  longitude       Float?
  locationVerified Boolean        @default(false) @map("location_verified")
  locationSource  String?         @map("location_source") // "whatsapp_share" | "text_extracted" | "manual"
  nationalCategory String?        @map("national_category")
  recommendedOffice String?       @map("recommended_office")
  status          ProblemStatus   @default(REPORTED)
  createdAt       DateTime        @default(now()) @map("created_at")
  updatedAt       DateTime        @default(now()) @updatedAt @map("updated_at")
  upvoteCount       Int             @default(0) @map("upvote_count")
  verificationCount Int             @default(0) @map("verification_count")
  resolvedBy        String?         @map("resolved_by") // Phone of volunteer who fixed it
  resolvedAt        DateTime?       @map("resolved_at")
  resolutionProof   String[]        @default([]) @map("resolution_proof") // Image URLs
  resolutionNotes   String?         @map("resolution_notes")
  averageRating     Float?          @map("average_rating")
  ratingCount       Int             @default(0) @map("rating_count")

  // AI Categorization & Analysis
  aiCategory          String?     @map("ai_category")
  aiCategoryConfidence Float?     @map("ai_category_confidence")
  imageAnalysis       Json?       @map("image_analysis")  // Stores vision AI results

  // Duplicate Detection
  embedding           Float[]     @default([])  // Vector embedding for similarity search
  duplicateOf         Int?        @map("duplicate_of")
  duplicateOriginal   Problem?    @relation("DuplicateLink", fields: [duplicateOf], references: [id])
  duplicates          Problem[]   @relation("DuplicateLink")

  // Severity Scoring
  severityScore       Float       @default(0) @map("severity_score")
  severityLastUpdated DateTime?   @map("severity_last_updated")

  upvotes         ProblemUpvote[]
  images          ProblemImage[]
  media           Media[]
  verifications   ProblemVerification[]
  responses       ProblemResponse[]
  ratings         ResolutionRating[]
  timelineEvents  ProblemTimelineEvent[]

  @@map("problems")
}

model ProblemImage {
  id        Int      @id @default(autoincrement())
  problemId Int      @map("problem_id")
  url       String
  mimeType  String   @map("mime_type")
  size      Int
  createdAt DateTime @default(now()) @map("created_at")
  problem   Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@map("problem_images")
}

model ProblemUpvote {
  problemId  Int     @map("problem_id")
  voterPhone String  @map("voter_phone")
  createdAt  DateTime @default(now()) @map("created_at")

  problem    Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@id([problemId, voterPhone])
  @@map("problem_upvotes")
}

model Media {
  id        Int      @id @default(autoincrement())
  problemId Int      @map("problem_id")
  url       String
  mimeType  String   @map("mime_type")
  size      Int
  createdAt DateTime @default(now()) @map("created_at")
  problem   Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@map("media")
}

model ProblemVerification {
  id          Int      @id @default(autoincrement())
  problemId   Int      @map("problem_id")
  fingerprint String   // Device fingerprint (hashed)
  latitude    Float
  longitude   Float
  imageUrls   String[] @map("image_urls") // UploadThing URLs
  createdAt   DateTime @default(now()) @map("created_at")
  
  problem     Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)
  
  @@unique([problemId, fingerprint]) // One verification per device per problem
  @@map("problem_verifications")
}

enum ResponseStatus {
  OFFERED
  ACCEPTED
  COMPLETED
  CANCELLED
}

model UserStats {
  id                    Int      @id @default(autoincrement())
  userPhone             String   @unique @map("user_phone")
  problemsReported      Int      @default(0) @map("problems_reported")
  upvotesGiven          Int      @default(0) @map("upvotes_given")
  verificationsGiven    Int      @default(0) @map("verifications_given")
  responsesOffered      Int      @default(0) @map("responses_offered")
  displayInLeaderboard  Boolean  @default(true) @map("display_in_leaderboard")
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  @@map("user_stats")
}

model ProblemResponse {
  id              Int            @id @default(autoincrement())
  problemId       Int            @map("problem_id")
  userPhone       String         @map("user_phone")
  fingerprint     String         // Device fingerprint (hashed)
  message         String?
  status          ResponseStatus @default(OFFERED)
  resolvedProblem Boolean        @default(false) @map("resolved_problem")
  beforeImages    String[]       @default([]) @map("before_images")
  proofImages     String[]       @default([]) @map("proof_images")
  createdAt       DateTime       @default(now()) @map("created_at")
  
  problem         Problem        @relation(fields: [problemId], references: [id], onDelete: Cascade)

  @@unique([problemId, fingerprint]) // One response per device per problem
  @@map("problem_responses")
}

model ResolutionRating {
  id                Int      @id @default(autoincrement())
  problemId         Int      @map("problem_id")
  raterPhone        String   @map("rater_phone")
  raterFingerprint  String   @map("rater_fingerprint")
  rating            Int      // 1-5 stars
  comment           String?
  createdAt         DateTime @default(now()) @map("created_at")
  
  problem           Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)
  
  @@unique([problemId, raterFingerprint]) // One rating per device per problem
  @@map("resolution_ratings")
}

model ProblemTimelineEvent {
  id          Int      @id @default(autoincrement())
  problemId   Int      @map("problem_id")
  eventType   String   @map("event_type") // REPORTED, UPVOTED, VERIFIED, HELP_OFFERED, RESOLVED
  actorPhone  String?  @map("actor_phone")
  metadata    Json?    // Store additional context
  createdAt   DateTime @default(now()) @map("created_at")
  
  problem     Problem  @relation(fields: [problemId], references: [id], onDelete: Cascade)
  
  @@map("problem_timeline_events")
}
